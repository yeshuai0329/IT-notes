## 一、变量声明

### 1、var 声明的变量

- 在代码执行前会进行预解析
- 同一个变量名可以重复定义
- 只有全局作用域和函数作用域，没有块级作用域
- 在函数内，函数的参数优先级高于变量
- var 声明的变量会挂载在window上



### 2、let 声明的变量

- let	没有预解析

- let	不能重复声明,在函数内部允许声明与形参相同的变量

- let	有块级作用域

- let	声明以后后期可以赋值

  

### 3、const  声明的变量

* const	没有预解析
* const	不能重复声明
* const	有块级作用域
* const	声明的时候要同时赋值，后期不能重复赋值（类似常量）
* 变量名一般全字母大写



**总结：**

1. var声明的变量，没有 **块级作用域** 的限制，let/const 声明的变量，具有 **块级作用域** 的限制。
2. var声明的变量存在 **变量提升** ，let/const 声明的变量，没有 **变量提升** 。
3. const 声明的是常亮，不能重新赋值，声明即赋值。



## 二、声明提升

- 使用 `var` 定义的变量会进行声明提升，会提升到 **全局作用域的顶端** 或者 **函数作用域的顶端**
- 使用 `var` 定义的函数表达式不会进行声明提升，`javascript`执行到它那一行才会解析。
- 函数声明 定义的函数会进行声明提升，会提升到 **全局作用域的顶端** 或者 **函数作用域的顶端**
- 如果 **函数声明** 和 **变量声明** 重复，那么函数声明就会覆盖变量声明。



## 三、预编译

> 在上下文创建以后, 并不会立即执行JS代码, 而是会先进行一个预编译的过程, 根据上下文的不同, 预编译又可以分为:
>
>  1. 全局预编译
>
>  2. 函数预编译： 
>
>     ​	每个执行上下文都有一个与之相关联的变量对象 (Variable Object, 简称 VO, 初其实就是一个对象：`{key : value}`形式) , 当前执行上下文中所有的`变量`和`函数`都添加在其中。

### 1.全局预编译解析流程

- `javascript` 的代码在执行之前会进行 `预编译`
- 查找变量声明，作为GO属性，值赋予undefined
- 查找函数声明，作为GO属性，值赋予函数体
- 如果函数声明和变量声明重复了，那么函数声明会覆盖变量声明



### 2.函数预编译

- 遇到变量声明, 变量名作为AO对象的属性名, 属性值置为 `undefined`
- 遇到函数声明, 函数名作为AO对象的属性名, 属性值为函数本身
- 如果函数名与变量名冲突（相同）, 函数声明会将变量声明覆盖, 属性值就是函数本身
- 预编译结束以后, 再逐行执行代码
- 

```javascript
function fn(a) {
  console.log(a);
  var a = 123;
  console.log(a);
  function a() { }

  console.log(a);
  console.log(b);
  var b = function () { }
  console.log(b);
}
fn(1);

GO：{
  fn: (a) {
    console.log(a);
    var a = 123;
    console.log(a);
    function a() { }

    console.log(a);
    console.log(b);
    var b = function () { }
    console.log(b);
  }
}

AO: {
  a: undefined,
}


// 函数编译四部曲
1. 创建AO对象，此时：
AO: {
  
}
2. 查找 形参 和 函数体内变量声明 并赋值 undefined, 此时：
AO: {
  a: undefined,
  b: undefined
}

3.将 实参 和 形参 统一，此时AO:
AO: {
  a: 1,
  b: undefined
}

4.寻找函数声明，赋值函数体，此时AO： 
AO: {
  a: function a() { },
  b: undefined
}

最后执行自上而下javascript代码
```

























